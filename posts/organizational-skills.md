---
title: Организационные навыки в программировании важнее алгоритмической магии
date: 2020-02-17
tag: dev
description: В программировании первостепенны организационные навыки, умение проектировать и способность управлять постоянно возрастающей сложностью информационных систем.
published: true
---

Перевод поста [«Organizational Skills Beat Algorithmic Wizardry»](https://prog21.dadgum.com/177.html) от James Hague.

Тезис автора — в программировании первостепенны организационные навыки, умение проектировать и способность управлять постоянно возрастающей сложностью информационных систем.

Возможно, это покажется кому-то спорным, особенно если брать области поиска или машинного обучения, но кажется, что мысли автора верны для разработки в целом. Важная ремарка — автор пишет лишь о приоритете способности организовать информационную систему над знаниями алгоритмов, что вовсе не отменяет того факта, что структуры данных и алгоритмы знать нужно, равно как и хорошо знать язык, на котором вы пишете, равно как и разбираться во многих сопутствующих областях.

---

Я видел много статей про технические собеседования в топовые компании, которые заставляли меня радоваться, что мне не нужно их проходить. Задачи реализовать чудаковатые варианты [куч](<https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)>) и [деревьев](<https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)>). Головоломки со сложными ограничениями. Числовые задачи, на решение которых требуется десять миллиардов лет, если вы не можете их проанализировать и найти хитрое математическое решение. Моей первой реакцией было — вау, как они вообще кого-то нанимают?

Моя вторая реакция заключалась в том, что в подавляющем количестве случаев в программировании не требуется такого рода алгоритмическая магия.

Когда дело доходит до написания кода, первым и самым важным навыком является способность удержать конструкцию от обрушения под тяжестью собственной сложности. Я работал над крупными телекоммуникационными системами, консольными играми, программным обеспечением для блогов, написал кучу инструментов для своей работы — и могу сказать, что крайне редко встречаются какие-то сложные структуры данных или алгоритмы, которые влияли бы на остальные части программы. Но часто и повсеместно встречается множество состояний, за которыми необходимо следить, реорганизация данных, обработка исключений и ошибок, тщательное проектирование взаимодействия всех частей системы между собой. В значительной степени акт программирования — это акт организации. Рефакторинга. Упрощения. Выяснения, как избавиться от ненужных манипуляций здесь и там.

Это причина, по которой существует так много "случайных" программистов. Вы не встретите людей, ненароком ставших нейрохирургами в свое свободное время — необходимая для этого подготовка очень специфична и слишком объемна — но многие люди набираются достаточно навыков программирования, чтобы уметь создавать разные вещи самостоятельно. Когда я учился программировать на своем 8-битном компьютере, я даже не знал, что такое алгоритм. Я понятия не имел, как сортировать данные, и, к счастью для тех небольших игр, которыми я в то время занимался, мне это и не требовалось. Код, который я писал тогда, был целиком и полностью про таймеры, счетчики и управление состоянием. Я был организатором, а не гением.

Несколько лет назад я написал небольшой инструмент, который строил из изображений прямоугольные текстуры. Это небольшая программа — возможно, 1500 строк на Erlang и С. Там был маленький сниппет на 20 строк, который и производил трансформацию в прямоугольные фигуры, и хотя его было нетрудно написать, я сомневаюсь, что смог бы реализовать такое во время собеседования. А весь остальной код отвечал за подгрузку файлов, генерацию вывода, обработку изображений (например, работу с исходниками) и управление потоком данных между разными частями программы. Именно с этими задачами я сталкиваюсь каждый раз, когда мне нужна новая функциональность, улучшенная обработка ошибок или оптимизация.

И это верно для подавляющей части разработки программного обеспечения.
